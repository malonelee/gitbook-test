---
title: Execution Model and Runtime
sidebar: mydoc_sidebar_docs
permalink: smart_contract/execution_model_and_runtime.html
folder: mydoc
---

This chapter describes the execution model, the data structures, and the life
cycle of Klaytn smart contracts.

## Execution Model

Transactions can be generated by platform APIs as described in
[Platform API Specification](../api/platform.html).  These
transactions are sent to *Consensus Nodes (CNs)* to be stored in a block.  The
CNs check whether each received transaction is valid.  Valid transactions are
stored in the transaction pool; otherwise, they are discarded.  A CN selects
the executable transactions in the current block in its transaction pool and
executes them one by one.

To execute a transaction, the sender must pay some amount of KLAY as a
transaction fee.  This transaction fee in KLAY is calculated based on gas and a
multiplier, *i.e.*, unit price.  A gas is the fundamental unit of computation.
Every operation executed on a Klaytn node consumes a predefined amount of gas.
The exact amount of KLAY required for the transaction is calculated by the
formula illustrated in [Transaction Fee](#transaction-fee).  The transaction
can fail if the sender submits a transaction accompanied by insufficient gas.
A transaction can also fail if the sender's account has an insufficient
balance.

When a transaction is executed successfully, it is included in the current
block.  A CN gathers transactions until it reaches block gas limit or block
time limit.  Then, the CN makes a block with the transactions.  This step
requires filling several fields in the block.  For example, it must calculate
the hash values of transactions, receipts, state, etc.  After all required
fields have been completed, the CN generates a block hash.

When block generation is complete, the block is propagated to all the other
CNs.  The other CNs all verify the propagated block and reach consensus on the
verification results by exploiting the BFT consensus algorithm.  When the
verification process completes successfully by the majority of CNs, the block
is stored in the blockchain.  Because the BFT consensus algorithm satisfies the
immediate finality property, the block is final and is never removed.  After a
block is finalized, the execution of all the transactions in that block are
irreversibly guaranteed, and their execution results can be returned to the
sender if requested.


### Restrictions on Transaction Execution

Klaytn's Aspen network currently has the following restrictions on the
transaction execution:
- A transaction cannot set its gas to the one greater than the block gas limit.
- A transaction must set its gas price to Klaytn's [unit price](#unit-price),
  *i.e.*, 25 Gpeb.
- A transaction cannot execute more than 3,000,000 opcodes.  If the number of
  opcodes that a transaction executes at run time is greater than 3,000,000,
  the transaction fails, and its failure is recorded on its receipt.   This is
  an experimental restriction to limit the transaction's execution time.


## Data Structures
### Account

The state of the Klaytn blockchain consists of the past and the current
**state** of Klaytn **accounts**.  Each account interacts with others while
producing new information that changes the state of the accounts and
consequently, changes the state of Klaytn.  The state information for each
account is associated with a 20-byte address, which is used to identify each
account.

There are three types of accounts: **externally owned accounts (EOAs)**,
**enterprise accounts (EAs)**  and **contract accounts**.  EOAs are controlled
by private keys and do not have code associated with them.  An EOA can be
created using a private key and subsequently controlled by anyone with the key.
In contrast, contract accounts have associated code and are controlled by their
code.  A contract account is created by a contract deployment transaction; once
deployed, a contract account cannot initiate new transactions by itself.
Transactions for a contract account must be triggered by another account,
either an EOA or another contract account.  An EA is a special purpose account
run by an enterprise proxy (EP) that allows a service provider to pay gas on
behalf of clients.  For details concerning an EA, please refer to
[Enterprise Account](../klaytn_design/enterprise_proxy.html#enterprise-account).


#### Address

An address is a 20-byte identifier used to recognize an account.  The state of
an account is associated with its address, and the address is used to invoke
a transaction from one account to another account.


#### Public/Private Keys

[//]: # "Describe what are public and private keys"

A private key is a large random number (32 bytes) and is used to generate a
public key.  An address is derived from the public key.  Additionally, a public
key is used to verify the signature for a transaction.  A transaction is signed
with a private key; afterward, others can verify, by using the public key,
whether the transaction is actually signed.

A private key, public key, and address are generated as follows.

1. Generate a random 32-byte private key.
   - A private key is a randomly selected positive integer in the range
    `[1, secp256k1n - 1]` and can be expressed as 64 hexadecimal characters
    (32 bytes).
2. Derive a 64-byte public key from a generated private key.
   - A public key is generated from a private key using the Elliptic Curve
     Digital Signature Algorithm (ECDSA).
3. Derive the 20-byte address from the public key.
   - Obtain the Keccak-256 hash of the 64-byte public key, which is a 32-byte
     string.
   - The last 20 bytes of this 32-byte string form the address.

NOTE: More detailed contents will be added soon.


#### Signing and Signatures

State transition operations in the Klaytn blockchain are made by executing
transactions.  Digital signatures are used to check whether a transaction was
legitimately created.  A user *signs* a transaction with his/her private key to
prove that they created the transaction.  Others can validate the *signature*
of a transaction using the signer's public key.  Although a signature is
created with a private key, the public key is sufficient to enable checking the
validity of a signature.


### Transaction

A transaction in Klaytn is a command that changes the state of the Klaytn
blockchain.  For example, when a transaction that sends 10 KLAY from Alice to
Bob is executed on Klaytn, Alice's balance decreases by 10 KLAY, and Bob's
balance increases by 10 KLAY.  Note that a transaction cannot be interleaved
with another transaction because a transaction is an atomic operation.

The table below shows the components in a transaction and their descriptions.

|Component name in caver.js| Description |
|---|---|
| value    | The value of the tokens to be transferred. |
| to       | The account address that receives the tokens. |
| input    | The data required to execute the transaction. |
| v, r, s  | The signature generated by the sender. This value is later used to obtain the sender's address. |
| nonce    | An integer value used to sequence sender's transactions. If two transactions with the same nonce are generated by a sender, only one is executed. |
| gas      | The maximum number of gas that the transaction is allowed to use. This is determined by the sender. If a transaction execution requires more gas than specified, it fails. |
| gasPrice | A multiplier of the transaction fee.  See [Transaction Fee](#transaction-fee) for details. |

[//]: # "TODO: revive 'Component name in Klaytn' column when needed."
[//]: # "Component Name in loo.js <-> Component Name in Klaytn"
[//]: # "value <-> Amount"
[//]: # "to <-> Recipient"
[//]: # "input <-> Payload"
[//]: # "v, r, s <-> V, R, S"
[//]: # "nonce <-> AccountNonce"
[//]: # "gas <-> GasLimit"
[//]: # "gasPrice <-> Price"

Transactions can be grouped into three categories: value transfer transactions,
smart contract execution transactions, and smart contract creation
transactions.


#### Value Transfer Transaction

A value transfer transaction is a transaction that simply sends `value` KLAY
from the sender to the recipient, specified by `to`.  Note that the sender's
address can be obtained from the signature `v, r, s`.  Value transfer
transactions are exactly the same as traditional banking transactions.
When a value transfer transaction executes, the specified token value is
transferred from the sender to the recipient.


#### Smart Contract Execution Transaction

A smart contract execution transaction executes a specified function in a
deployed smart contract.  The component `to` should contain a smart contract
address.  Which function executes in the smart contract depends on the `input`
value; `input` also contains the function arguments required by the function.
This type of transaction can transfer `value` KLAY to the smart contract only
if the calling function is *payable*.  It is worth noting that `gas` should be
sufficient to execute the specified function of the smart contract.


#### Smart Contract Creation Transaction

A smart contract creation transaction deploys a smart contract.  In this type
of transaction, `to` should be set to null, and the contract address to be
created is calculated by hashing the sender's address and nonce.  The `input`
should be set to the binary of the smart contract to be deployed.


### State

Klaytn's **state** is a collection of account states.  This state must be the
same across Klaytn nodes if they have processed the same blocks in the same
order.  The state is changed when a transaction is executed on a Klaytn node.

The table below shows the account data that are stored in the state.

| Component   | Description |
|---|---|
| Nonce       | An integer value indicating the number of transactions executed by this account. To submit a transaction with the account, the `nonce` of the transaction should be one greater than the account's nonce. |
| Balance     | An integer value showing the amount of KLAY that this account currently has. |
| StorageRoot | A 256-bit hash of the root of the Merkle Patricia Trie that contains the values of all the storage variables in the account. |
| CodeHash    | The hash of the account's bytecode.  This value is immutable, which means it is set only when the smart contract is created.  If the account is an EOA or an EA, this value is set to the hash of null. |


### Block

A block is a crucial element of the Klaytn blockchain because the blockchain
literally consists of a chain of blocks.  The table below shows the components
in a block.

[//]: # "NOTE: We don't describe block's components that may be irrelevant with Klaytn."

| Component | Description |
|---|---|
| ParentHash   | The hash of the block's parent block. |
| Coinbase     | TBD |
| Rewardbase   | The account address receiving the block reward. |
| Root         | The hash of the root of the Merkle Patricia Trie of the blockchain state. |
| TxHash       | The hash of the transactions included in the block. |
| ReceiptHash  | The hash of the receipts of transactions included in the block. |
| Bloom        | The Bloom filter value of the receipts. |
| Number       | An integer value equal to the number of ancestor blocks. |
| GasLimit     | The maximum number of gas that the block is allowed to use. |
| GasUsed      | The number of gas used to process transactions in the block. |
| Time         | An integer value equal to the Unix timestamp when the block was generated. |
| Extra        | TBD |
| MixDigest    | TBD |
| Nonce        | TBD |
| Transactions | The transactions included in the block. |

[//]: # "NOTE: the below exists originally in Ethereum's block"
[//]: # "Difficulty: The difficulty level of the block."
[//]: # "Td: The total difficulty of the chain up to and including this block"


## Smart Contract

[//]: # (Partly imported from http://www.ethdocs.org/en/latest/contracts-and-transactions/contracts.html)

A *smart contract* consists of a collection of code (functions) and data
(state) that resides at a specific address on the Klaytn blockchain.  Contract
accounts are able to pass messages between each other as well as perform
practically Turing complete computation.  Contracts exist on the blockchain in
Klaytn-specific binary formats.  Currently, Klaytn supports one binary format
--Ethereum Virtual Machine (EVM) bytecode; however, other formats will be
supported in the future.


### Creating Smart Contracts

A smart contract can be created in the Klaytn blockchain by sending a
transaction to an empty address with the binary as data.  The binary can be in
various formats; however, Klaytn currently supports one binary format, EVM
bytecode, as described earlier.  It is worth pointing out that this transaction
requires a payment for execution.  The account balance on the sender's account
will be reduced according to the transaction fee model after the transaction
has been stored in a block.  After some time, the transaction should appear in
a block, which confirms that the state it entails reached a consensus.  At this
point, the smart contract now exists in the Klaytn blockchain.


### Executing Smart Contracts

A function of a smart contract can be called and executed either by sending a
transaction to the smart contract or by calling the function locally in the node.

- When a function is called by sending a transaction, the function is executed
  by processing a transaction.  This entails a cost in KLAY for sending the
  transaction, and the call will be recorded forever on the blockchain.  The
  return value of calls made in this manner is the hash of the transaction.
- When the function is invoked locally, it is executed locally in the Klaytn
  Virtual Machine (KLVM), and the call returns the return value of the
  function.  Calls made in this manner are not recorded on the blockchain;
  thus, they cannot modify the internal state of the contract.  This type of
  call is referred to as a constant function call.  Calls made in this manner
  do not cost any KLAY.

Constant function calls should be used when only the return value is of interest,
while a transaction should be used when side effects on the contract state are
of interest.


### Disabling Smart Contracts

Because smart contracts exist in the Klaytn blockchain, they cannot be deleted;
they can only be disabled.

For now, Klaytn has adopted the same process for disabling a Klaytn smart
contract as is used for disabling smart contracts in Ethereum.  For example,
the Klaytn smart contract for KLVM can be disabled by using the
[`selfdestruct(address recipient)`](https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html#self-destruct)
call in Solidity (or the KLVM opcode `SELFDESTRUCT`).  The Klaytn team will
also provide ways to disable smart contracts for other execution environments.


### Upgrading Smart Contracts

[//]: # (https://github.com/ground-x/whitepaper/blob/master/en/positionPaper.md#inconvenient-user-experience-ux)
Klaytn will provide ways to upgrade a deployed smart contract to address the
inconvenient user experience with existing blockchains.  For example, deployed
services on blockchains are difficult to upgrade.  Klaytn will provide
frameworks and smart contract libraries to enable service providers (SPs) to
upgrade deployed services and migrate service information.  Klaytn will provide
this feature carefully by considering the following requirements.

- Only authorized accounts or the owner of a smart contract should be able to
  upgrade the smart contract.
- Upgraded smart contracts should be able to manipulate existing data
  maintained by the old smart contract.
- Other smart contracts that refer to the old smart contracts should be able to
  determine whether to use newer, upgraded versions of those smart contracts.


## Klaytn Tokens and Transaction Fees

### KLAY

KLAY is the main internal transferable cryptocurrency of Klaytn and is used to
pay transaction fees when creating or executing smart contracts or when
transferring KLAY.

[//]: # (https://github.com/ethereum/wiki/wiki/White-Paper#ethereum-accounts)
[//]: # (https://www.ethereum.org/ether)
KLAY is a necessary element--a fuel--for operating the Klaytn distributed
application platform.  It is a form of payment made by the clients of the
platform to the consensus nodes (CNs) executing the requested operations.
To put it another way, KLAY is an incentive; it ensures that developers write
high-quality applications (wasteful code costs more) and that the network
remains healthy (CNs and RNs are compensated for the resources they
contribute).


#### Units of KLAY

Klaytn uses the following unit system for KLAY.
- `peb` is the smallest currency unit.
- `ston` is an alias for `Gpeb` and introduced for convenience.
- A `KLAY` is 10<sup>18</sup> peb.

Unit | peb value | peb
---- | --------- | ---
peb | 1 peb | 1
kpeb | 10<sup>3</sup> peb | 1,000
Mpeb | 10<sup>6</sup> peb | 1,000,000
Gpeb | 10<sup>9</sup> peb | 1,000,000,000
ston | 10<sup>9</sup> peb | 1,000,000,000
uKLAY | 10<sup>12</sup> peb | 1,000,000,000,000
mKLAY | 10<sup>15</sup> peb | 1,000,000,000,000,000
KLAY | 10<sup>18</sup> peb | 1,000,000,000,000,000,000
kKLAY | 10<sup>21</sup> peb | 1,000,000,000,000,000,000,000
MKLAY | 10<sup>24</sup> peb | 1,000,000,000,000,000,000,000,000
GKLAY | 10<sup>27</sup> peb | 1,000,000,000,000,000,000,000,000,000
TKLAY | 10<sup>30</sup> peb | 1,000,000,000,000,000,000,000,000,000,000


#### APIs Related to KLAY Units

[//]: # "TODO: Move this API description to a proper place"
[//]: # "TODO: Use our namespace instead of web3"

`web3.toPeb` and `web3.fromPeb` are convenient APIs for converting between KLAY
units.
```
$ ./klay attach data/dd/klay.ipc
...
> web3.fromPeb(25, "peb")
"25"
> web3.fromPeb(25, "Gpeb")
"0.000000025"
> web3.fromPeb(25, "ston")
"0.000000025"
> web3.fromPeb(25, "KLAY")
"0.000000000000000025"
> web3.toPeb(25, "peb")
"25"
> web3.toPeb(25, "ston")
"25000000000"
> web3.toPeb(25, "KLAY")
"25000000000000000000"
```

You can get the list of all units supported by `web3.toPeb` and `web3.fromPeb` by
sending an invalid unit string such as the one below.
```
> web3.toPeb(1, "something-does-not-exist")
Error: This unit doesn't exist, please use one of the following units
"noKLAY": "0"
"peb": "1"
"kpeb": "1000"
"Mpeb": "1000000"
"Gpeb": "1000000000"
"ston": "1000000000"
"uKLAY": "1000000000000"
"mKLAY": "1000000000000000"
"KLAY": "1000000000000000000"
"kKLAY": "1000000000000000000000"
"MKLAY": "1000000000000000000000000"
"GKLAY": "1000000000000000000000000000"
"TKLAY": "1000000000000000000000000000000"

    at web3.js:2170:19
    at web3.js:2255:49
    at <anonymous>:1:1
```


### Transaction Fee

Transaction fees can be calculated in various ways depending on the execution
environment where the transaction is executed.  For example, the transaction
fee for the current Klaytn virtual machine (KLVM) is computed as follows:

[//]: # "TODO: describe a step-wise pricing function instead of pointing out the position paper"

```
Transaction fee := F( (total gas used) x (unit price) )
```
- `F()` could be a stepwise pricing function as described in the position
  paper.  This function is not finalized yet; thus, it might be changed during
  the development of Klaytn.  For the Klaytn test networks, `F()` is an
  identity function, and the transaction fee is simply calculated as
  `(total gas used) x (unit price)`.
- The `total gas used` is computed by KLVM based on the gas cost of the opcode
  and the intrinsic gas cost.
  See [Fee Overview](klaytn_virtual_machine.html#fees-overview) for more details.
- `unit price` is the price of gas defined in Klaytn.

This calculated transaction fee is subtracted from the sender's or enterprise
account's balance, depending on the transaction.


#### Unit Price

In Klaytn, the unit price is the fixed price of gas defined in the platform and
is used to calculate the transaction fee.  It is currently set to 25 Gpeb
(*i.e.*, 25 x 10<sup>9</sup> peb) per gas and cannot be changed by user.  The
current value of the unit price can be obtained by calling the `klay.gasPrice`
API.


#### Transaction Validation against Unit Price

Klaytn only accepts transactions with gas prices, which can be set by the user,
that are equal to the unit price of Klaytn; it rejects transactions with gas
prices that are different from the unit price in Klaytn.

[//]: # "Therefore, developer is using `web3.js`, he/she should set the gas price of transactions to the unit price of Klaytn."


#### Unit Price Error

The error message `invalid unit price` is returned when the gas price of
a transaction is not equal to the unit price of Klaytn.


#### Transaction Replacement

Klaytn currently does not provide a way to replace a transaction using the unit
price but may support different methods for the transaction replacement in the
future.  Note that in Ethereum, a transaction with a given nonce can be
replaced by a new one with a higher gas price.

[//]: # (TODO: Do we need to describe the differences from different from Ethereum here?)
